# 数据结构与算法 js版

## 复杂度

### 时间复杂度

***时间复杂度：定型的描述算法的运行时间***

几个常见的时间复杂度

O(1) O(n) O(n^2) O(logn)

```js
//时间复杂度O(1)
let i 
i +=1

//时间复杂度 O(n)
for(let i=1;i<n;i++){
	console.log(i)
}

//时间复杂度 O(n^2)
for(let i = 1; i<n ;i ++){
    for(let j =1 ; j<n;j++){
        
    }
}

//时间复杂度 O(logn)
let i = 1
while(i<n){
    console.log(i)
    i *= 2
}
```

------

### 空间复杂度

**算法在运行过程中临时占用存储空间大小的量度**

似乎可以理解为变量所占内存的大小

常见的空间复杂度 O(1) O(n) O(n^2)

```js
//空间复杂度 O(1)
let i
i +=1

// O(n)
const list = []
for(let i =1;i<n;i++){
    list.push(i)
}

// O(n^2)
const matrix = []
for(let i=0;i<n;i++){
    martix.push([])
    for(let j =0;j<n;j++){
        matrix[i].push(j)
    }
}
```

------



## 数据结构

### 栈

**后进先出的数据结构**

应用场景

- 十进制转二进制
- 有用的括号
- 函数调用堆栈 ，最后调用的函数，最先执行完

------

### 队列

先进先出的数据结构

## 排序算法

## 冒泡排序

冒泡排序步骤，从第一个开始比较，一直比较相邻的两个元素，通过两个元素的大小，交换两个元素，针对所所有的元素重复这一步骤，除了最后一个，所以要比较 **length-1**轮，同时每一个元素要比较length-i-1次

具体实现 从小到大

```js
function bubbleSort(arr){
    for(let i=0 ; i < arr.length - 1 ; i++) {
        for(let j=0 ; j<arr.length - i -1 ; j++){
            if(arr[j]>arr[j+1]){
                let temp = arr[j+1]
                arr[j+1] = a[j]
                arr[j] = temp 
            }
        }
    }
    return arr
}
```

------

### 选择排序

选择排序步骤，从第一开始比较，找出序列中最小的元素，将它和第一个元素调换位置，以此类推，在从第二个元素开始，找出序列中最小的元素和第二个元素调换位置，如此往下，便可以排序完成。

具体实现 从小到大

```js
function selectionSort(arr){
    let len = arr.length
    let minIndex,temp
    for(let i=0 ; i<len-1 ; i++){
        minIndex = i
        for(let j = i+1 ; j< len ; j++) {
            if(arr[j] < arr[minIndex]) {
                minIndex = j
            }
        }
        temp = arr[minIndex]
        arr[minIndex] = arr[i]
        arr[i] = temp
    }
    return arr
}
```

------

### 插入排序

插入排序步骤：将第一个元素看成有序序列，后面的元素都看成无序序列，通过后面的元素依次与前面的元素比较，如果比之前有序序列的元素小，则插入，如果大，则插入到前面序列的后面，保证了顺序

具体实现 从小到大

```js
function insertSort(arr){
    let len = arr.length
    for(let i =1 ; i<len;i++){
        let currentValue = arr[i] //存储当前的要比较的元素
        let j = i-1 //要比较序列元素的最后的一个索引
        while(j >=0 && currentValue < arr[j]){
            arr[j+1] = arr[j] //有序序列元素后移一位
            j--
        }
        arr[j+1] = currentValue //将比较的元素插入到有序序列中
    }
    return arr
}
```

------

### 快速排序

快速排序步骤：快速排序步骤，在待排序的序列中找到一个基准，通过这个基准将序列分为左右两个部分，如此递归进行

具体实现 从小到大

```js
function quickSort(arr) {
            if (arr.length <= 1) return arr
            let left = []
            let right = []
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < arr[0]) {
                    left.push(arr[i])
                } else {
                    right.push(arr[i])
                }

            }
            left = quickSort(left)
            right = quickSort(right)
            left.push(arr[0])
            return left.concat(right)
        }
```